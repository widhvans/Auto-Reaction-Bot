import os
import time
import asyncio
import datetime
import aiofiles
from random import choice
from pyrogram import Client, filters
from pyrogram.types import InlineKeyboardMarkup, InlineKeyboardButton, Message
from pyrogram.errors import *
from database import Database
from config import *

# Database initialization
db = Database(DATABASE_URL, "autoreactionbot")

# Bot setup
Bot = Client(
    "Auto Reaction Bot",
    bot_token=BOT_TOKEN,
    api_id=API_ID,
    api_hash=API_HASH,
)

# Messages and buttons
START_TEXT = """<b>{},

…™ ·¥Ä·¥ç s…™·¥ç·¥ò ü·¥á  ô·¥ú·¥õ ·¥ò·¥è·¥°·¥á ÄÍú∞·¥ú ü ü ·¥Ä·¥ú·¥õ·¥è  Ä·¥á·¥Ä·¥Ñ·¥õ…™·¥è…¥  ô·¥è·¥õ.

·¥ä·¥ús·¥õ ·¥Ä·¥Ö·¥Ö ·¥ç·¥á ·¥Äs ·¥Ä ·¥Ä·¥Ö·¥ç…™…¥ …™…¥  è·¥è·¥ú Ä ·¥Ñ ú·¥Ä…¥…¥·¥á ü ·¥è Ä …¢ Ä·¥è·¥ú·¥ò ·¥õ ú·¥á…¥ s·¥á·¥á ·¥ç è ·¥ò·¥è·¥°·¥á Ä

<blockquote>·¥ç·¥Ä…™…¥·¥õ·¥Ä…™…¥·¥á·¥Ö  ô è : <a href='https://telegram.me/CallOwnerBot'> Ä·¥Ä ú·¥ú ü</a></blockquote></b>"""

LOG_TEXT = """<b>#NewUser
    
ID - <code>{}</code>

Name - {}</b>"""

START_BUTTONS = InlineKeyboardMarkup(
    [[
        InlineKeyboardButton(text='‚áÜ ·¥Ä·¥Ö·¥Ö ·¥ç·¥á ·¥õ·¥è  è·¥è·¥ú Ä …¢ Ä·¥è·¥ú·¥òs ‚áÜ', url=f'https://telegram.me/{BOT_USERNAME}?startgroup=botstart')
    ],[
        InlineKeyboardButton(text='‚Ä¢ ·¥ú·¥©·¥Ö·¥Ä·¥õ·¥áÍú± ‚Ä¢', url='https://telegram.me/StreamExplainer'),
        InlineKeyboardButton(text='‚Ä¢ Íú±·¥ú·¥©·¥©·¥è Ä·¥õ ‚Ä¢', url='https://telegram.me/TechifySupport')
    ],[
        InlineKeyboardButton(text='‚áÜ ·¥Ä·¥Ö·¥Ö ·¥ç·¥á ·¥õ·¥è  è·¥è·¥ú Ä ·¥Ñ ú·¥Ä…¥…¥·¥á ü ‚áÜ', url=f'https://telegram.me/{BOT_USERNAME}?startchannel=botstart')
    ]]
)


# Helper functions
async def send_msg(user_id, message):
    try:
        await message.copy(chat_id=user_id)
        return 200, None
    except FloodWait as e:
        await asyncio.sleep(e.value)
        return send_msg(user_id, message)
    except (InputUserDeactivated, UserIsBlocked):
        return 400, f"{user_id} : error\n"
    except Exception as e:
        return 500, f"{user_id} : {str(e)}\n"

async def get_fsub(bot, message):
    target_channel_id = AUTH_CHANNEL  # Your channel ID
    user_id = message.from_user.id
    try:
        # Check if user is a member of the required channel
        await bot.get_chat_member(target_channel_id, user_id)
    except UserNotParticipant:
        # Generate the channel invite link
        channel_link = (await bot.get_chat(target_channel_id)).invite_link
        keyboard = [[InlineKeyboardButton("üîî Join Our Channel", url=channel_link)]]

        # Display a message encouraging the user to join
        await message.reply(
            f"<b>üëã Hello {message.from_user.mention()}, Welcome!</b>\n\n"
            "üì¢ <b>Exclusive Access Alert!</b> ‚ú®\n\n"
            "To unlock all the amazing features I offer, please join our updates channel. "
            "This helps us keep you informed and ensures top-notch service just for you! üòä\n\n"
            "<i>üöÄ Join now and dive into a world of knowledge and creativity!</i>",
            reply_markup=InlineKeyboardMarkup(keyboard),
        )
        return False
    else:
        return True


# Handlers
@Bot.on_message(filters.private & filters.command(["start"]))
async def start(bot, update):
    if not await db.is_user_exist(update.from_user.id):
        await db.add_user(update.from_user.id)
        await bot.send_message(LOG_CHANNEL, LOG_TEXT.format(update.from_user.id, update.from_user.mention))
    
    is_subscribed = await get_fsub(bot, update)
    if not is_subscribed:
        return

    await update.reply_text(
        text=START_TEXT.format(update.from_user.mention),
        disable_web_page_preview=True,
        reply_markup=START_BUTTONS
    )

@Bot.on_message(filters.private & filters.command("users") & filters.user(BOT_OWNER))
async def users(bot, update):
    total_users = await db.total_users_count()
    text = f"Bot Status\n\nTotal Users: {total_users}"
    await update.reply_text(
        text=text,
        quote=True,
        disable_web_page_preview=True
    )

@Bot.on_message(filters.private & filters.command("broadcast") & filters.user(BOT_OWNER) & filters.reply)
async def broadcast(bot, update):
    broadcast_ids = {}
    all_users = await db.get_all_users()
    broadcast_msg = update.reply_to_message
    out = await update.reply_text(text="Broadcast Started!")
    start_time = time.time()
    total_users = await db.total_users_count()
    done = 0
    failed = 0
    success = 0
    broadcast_ids["broadcast"] = {"total": total_users, "current": done, "failed": failed, "success": success}

    async with aiofiles.open('broadcast.txt', 'w') as broadcast_log_file:
        async for user in all_users:
            sts, msg = await send_msg(user_id=int(user['id']), message=broadcast_msg)
            if msg is not None:
                await broadcast_log_file.write(msg)
            if sts == 200:
                success += 1
            else:
                failed += 1
            if sts == 400:
                await db.delete_user(user['id'])
            done += 1

            broadcast_ids["broadcast"].update({"current": done, "failed": failed, "success": success})

    completed_in = datetime.timedelta(seconds=int(time.time() - start_time))
    await asyncio.sleep(3)
    await out.delete()
    if failed == 0:
        await update.reply_text(
            text=f"Broadcast completed in `{completed_in}`\n\nTotal users {total_users}.\nDone: {done}, Success: {success}, Failed: {failed}",
            quote=True
        )
    else:
        await update.reply_document(
            document='broadcast.txt',
            caption=f"Broadcast completed in `{completed_in}`\n\nTotal users {total_users}.\nDone: {done}, Success: {success}, Failed: {failed}"
        )
    os.remove('broadcast.txt')

# Reaction handling
@Bot.on_message(filters.all)
async def send_reaction(_, msg: Message):
    try:
        # Assuming Config.EMOJIS is a predefined list of emojis
        await msg.react(choice(EMOJIS))
    except:
        pass

# Start bot
Bot.run()
